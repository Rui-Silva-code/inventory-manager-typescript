import api from "./client";
import type { Product, ProductPatch } from "../types/product";

/**
 * GET /products
 * Returns a list of products. We return Promise<Product[]> to indicate that the resolved value will be an array of Product objects. If your backend returns a different structure (like { products: Product[] }), you can adjust the return type and the return statement accordingly.
 */
export const getProducts = async (): Promise<Product[]> => {
  const res = await api.get("/products");
  return res.data as Product[];
};

/**
 * POST /products
 * We use ProductPatch here because when creating a product, you might not have an id yet (since it's usually generated by the backend). If your backend requires an id on creation, you can change this to use Product instead of ProductPatch and ensure you send all fields when calling createProduct.
 */
export const createProduct = async (product: ProductPatch): Promise<unknown> => {
  const res = await api.post("/products", product);
  return res.data;
};

/**
 * PUT /products/:id
 * We use ProductPatch here because you might only update a few fields at a time.
 * If your backend requires all fields for updates, you can change this to use Product instead of ProductPatch and ensure you send all fields when calling updateProduct.
 */
export const updateProduct = async (id: string, product: ProductPatch): Promise<unknown> => {
  const res = await api.put(`/products/${id}`, product);
  return res.data;
};

/**
 * DELETE /products/:id
 * Delete endpoints often return nothing important, so we return Promise<void>.
 * If your backend returns something useful (like the deleted product), you can change this to Promise<Product> and return res.data as Product.
 */
export const deleteProduct = async (id: string): Promise<void> => {
  await api.delete(`/products/${id}`);
};
